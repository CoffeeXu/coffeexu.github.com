
<!DOCTYPE HTML>
<html lang="en-GB">
<head>
	<meta charset="utf-8">
	<title>  | 所以。</title>

	<meta name="author" content="许嘘嘘">

<meta name="description" content="tags: CSS position float display position position属性取值：static(默认)、relative、absolute、fixed、inherit。
postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位 &hellip;"> <meta name="keywords" content="">

	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="所以。" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- 连接新窗口打开 -->
<script>
function addBlankTargetForLinks () {
  $('.entry-content a[href]').each(function(){
      $(this).attr('target', '_blank');
  });
}

$(document).bind('DOMNodeInserted', function(event) {
  addBlankTargetForLinks();
});
</script>
</head>



<body>
	<header id="header" class="inner"><h1><a href="/">所以。</a></h1>
<span class="tagline"></span>
<nav id="main-nav" class＝"tagline"><ul>
	<li><a href="/about">许嘘嘘/About</a></li>
	<li><a href="/">这里/Blog</a></li>
	<li><a href="/code">温吞/Code</a></li>
</ul>
</nav>
<!-- <nav id="mobile-nav"> -->
<!-- 	<div class="alignleft menu"> -->
<!-- 		<a class="button">Menu</a> -->
<!-- 		<div class="container"><ul>
	<li><a href="/about">许嘘嘘/About</a></li>
	<li><a href="/">这里/Blog</a></li>
	<li><a href="/code">温吞/Code</a></li>
</ul>
</div> -->
<!-- 	</div> -->
<!-- </nav> -->


</header>

	<div id="content" class="inner">


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/30/css-position-float-display">
			
				讲一讲CSS的position/float/display</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-30T21:51:00+08:00" pubdate data-updated="true">Oct 30<span>th</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>CSS</code> <code>position</code> <code>float</code> <code>display</code></p>

<br>


<h3>position</h3>

<ol>
<li><p>position属性取值：static(默认)、relative、absolute、fixed、inherit。</p></li>
<li><p>postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让top，right，bottom，left的值失效。在切换的时候可以尝试这个方法。</p></li>
<li>除了static值，在其他三个值的设置下，z-index才会起作用。（确切地说z-index只在定位元素上有效）</li>
<li>position：relative和absolute都可以用于定位，区别在于前者的div还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。定位原点relative是相对于它在正常流中的默认位置偏移，它原本占据的空间任然保留；absolute相对于第一个position属性值不为static的父类。所以设置了position：absolute，其父类的该属性值要注意，而且overflow：hidden也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。</li>
<li>fixed旧版本IE不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。常用于header，footer，或者一些固定的悬浮div，随滚动条滚动又稳定又流畅，比JS好多了。fixed可以有很多创造性的布局和作用，兼容性是问题。</li>
<li>position：inherit。规定从父类继承position属性的值，所以这个属性也是有继承性的。</li>
</ol>


<h3>float</h3>

<ol>
<li>float属性取值：none(默认)、left、right、inherit。</li>
<li>float：left(或right)，向左（或右）浮动，直到它的边缘碰到包含框或另一个浮动框为止。且脱离普通的文档流，会被正常文档流内的块框忽略。不占据空间，无法将父类元素撑开。</li>
<li>任何元素都可以浮动，浮动元素会生成一个块级框，不论它本身是何种元素。因此，没有必要为浮动元素设置display：block。</li>
<li>如果浮动非替换元素，则要指定一个明确的width，否则它们会尽可能的窄。（什么叫替换元素？根据元素本身的特点定义的， (X)HTML中的img、input、textarea、select、object都是替换元素，这些元素都没有实际的内容。 (X)HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。）</li>
</ol>


<h4>清浮</h4>

<ol>
<li>最直接的clear属性，该属性表示的是框的哪边不应该挨着浮动框。这个属性是对元素本身而言，通过自动为该元素增加上外边距实现的（css1和css2），或者在上外边距之上增加清除空间，而外边距本身不改变的方式（css2.1）。clear的缺陷是可能要添加额外无意义的标签。</li>
<li>通过父类的浮动也可以清理子类浮动，将空间撑开。这有点像负负得正。但原理应该是浮动的元素也是按照文档流的方式布局，只不过它们是另外一个独立的文档流，不同于普通文档流，暂时叫它浮动文档流？</li>
<li>hasLayout和BFC都可以清理浮动。overflow：hidden；zoom:1；hasLayout跟BFC不同之处，前者被限制为一个矩形，可以设置宽高，但BFC不一定可以设置宽高（比如行内元素）。</li>
</ol>


<h3>display</h3>

<ol>
<li>display属性取值：none、inline、inline-block、block、table相关属性值、inherit以及list-item, run-in等</li>
<li>display属性规定元素应该生成的框的类型。文档内任何元素都是框，块框或行内框。</li>
<li>display：none和visiability：hidden都可以隐藏div，区别有点像absolute和relative，前者不占据文档的空间，后者还是占据文档的位置。</li>
<li>display：inline和block，又叫行内元素和块级元素。表现出来的区别就是block独占一行，在浏览器中通常垂直布局，可以用margin来控制块级元素之间的间距（存在margin合并的问题，就是@ 寒冬winter 磨叽的margin collapse么- &ndash;||，插一句， 只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。）；而inline以水平方式布局，垂直方向的margin和padding都是无效的，大小跟内容一样，且无法设置宽高。inline就像塑料袋，内容怎么样，就长得怎么样；block就像盒子，有固定的宽和高。</li>
<li>inline-block就介于两者之间。inline-block行内块元素。内容被格式化为块元素，而元素本身是一个行内元素。可以设置宽高，又默认不换行特性。IE表现出来的效果不一样，所以需要激发hasLayout，所以就产生了这么一串代码{display:inline-block;<em>display:inline; </em>zoom:1;}。但是不一定要这么累赘，因为还有其他值也可以激发hasLayout，比如height/width。inline-block跟float可以达到同样的布局效果。效果哪个好不好说，前者不会打破文档正常的定位机制，后者就脱离了正常的文档流。完全看具体布局情况选择。另外，激发hasLayout之后的并且设置display：inline的元素，跟普通文字一样按水平方向排列，受vertical-align的影响，并且可以按照容器大小自适应调整。</li>
<li>table相关的属性值可以用来垂直居中，效果一般。</li>
</ol>


<h3>定位机制</h3>

<ol>
<li>上面三个属性都属于CSS定位属性。CSS三种基本的定位机制：普通流、浮动、绝对定位。</li>
</ol>


<h4>随便扯一些居中布局：</h4>

<ul>
<li>宽高固定可以利用负margin。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.center{top：50%;margin-top:-height/2;left:50%;margin-left:-width/2;}</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>宽高不固定的元素。.center{display：inline-block},父类设置{text-align:center}</p></li>
<li><p>垂直居中table-cell不说了</p></li>
<li><p>{line-height：height;vertical-align:middle;}</p></li>
<li><p>{position:absolute;top:0;bottom:0;margin:auto}别忘记给父类定位{position:relative;}</p></li>
</ul>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/27/just-do-it">
			
				去做，才有困难可言</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-27T15:39:00+08:00" pubdate data-updated="true">Oct 27<span>th</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>梦想清单</code></p>

<br>


<p>花了十个月，才完成了原来在连客上写下的清单(其实Evernote里还有好多个清单)</p>

<p><img src="/images/blog/20131027.jpg"></p>

<p>好像也不知道做完了有什么意义，也很难感受当时写下这些想要去做的心情。就好像我一直不能理解小时候说长大要当作家的心情是一样一样的。</p>

<h4>买一台MAC</h4>

<p>现在的笔记本是五月底买的，给自己当作六一儿童节的礼物。以前的联想就被丢在家里积灰尘，很多大学时期的东西就跟过气的笔记本一样被闲置。说来也奇怪，明明有时候好像是那么念旧的一个人，很多有用没用的东西总是舍不得丢掉，很多过去的人和事总是有一岔没一岔的想起，但是又会在应该柔软的时候，gin得跟什么一样。像从来没有回访过母校，我也就在每次路过严分的时候，会呵呵下；或者看到工大校庆的各种转发，打个已阅的标签。</p>

<p>其实现在也很少开电脑了，下了班也很少再有心情去码代码。苹果系统感觉还没有用得很顺，所以也没有体会到效率的提高。好吧，压根就没有在码代码，提高毛线啊。</p>

<h4>养一只叫&#8221;萌萌&#8221;的猫</h4>

<p>从别人那里领养来一只小母喵，两三个月大的家猫，黑不溜秋的，被好多人嫌弃，小能一直强调“丑哭了！”，但是我还是觉得挺不错的呀，小喵都挺萌的，不过名字没有叫萌萌，花花小八土豆，都是别人取的，反正现在叫什么她都是不会应和的，一直沉浸在自己的世界里发神经！真的是特别神经。不知道是不是小时候都这样皮，到长大了就好点了吧懒懒的了。我不是很有耐心的人，老是烦我我就会教训她，她就会有点害怕我，但晚上还是会在我门口喵喵地叫，求我放她进来睡觉。可是我多无情的人啊，不管她。小时候还是要教好，不能养成恶习。白天还是开着门让她跑来跑去发神经。教了两次已经会上厕所，表扬一下。</p>

<p>我还是希望可以把她养得胖胖的，周末可以坐在我腿上晒太阳，看我上网矫情。</p>

<p>养猫还是一件麻烦的事情，因为对她做什么她都是不会领情的。我是独立的，她也是独立的。我对她抚摸她根本就没有在享受，我表扬她大概她也感受不到吧。我在想我养她长大，我们彼此会有感情吗？</p>

<h4>去北京，旅行</h4>

<p>呵呵。<a href="/blog/2013/10/23/travel-to-beijing">带着痘痘来北京看人头</a></p>

<p>所以所有这些，都被我当作体验，感受过就好了吧，没什么不同的。</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/23/travel-to-beijing">
			
				带着痘痘来北京看人头</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-23T20:32:00+08:00" pubdate data-updated="true">Oct 23<span>rd</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>梦想清单</code> <code>旅行</code></p>

<br>


<p>本来十一要去稻城，房间太贵，便宜的都定完了，穷人一枚住不起就算了，想说安心回家看中医治疗痘痘去。</p>

<p>但是内心始终不甘心啊，这么长的假期宅在家里不出去玩，以后都没有机会了。而且毕业旅行也是一直都欠着。</p>

<p>but！30号的时候，看到3号飞天津的打折机票只要390不到点，北京情节就来了，说赶紧的看看房间，能订到房就去北京。</p>

<p>好巧不巧的看到豆瓣上一家所谓的北京民宿，随口问了下居然有房间。直接就头脑发热定下了，不能退房，后来一直担心房间会不会不安全，搞的来北京就一直怕怕的。最后定了7号晚上返程的高铁。</p>

<p>在自己的房间浑浑噩噩混过了1号2号，2号晚上老早就洗头洗澡睡觉，第二天四五点爬起来赶飞机。第一次坐飞机，激动死了，还好巧不巧的在窗边，可以看看云层以上的天空啦。最后发现，这趟北京之旅唯一的收获就是坐飞机，这是后话。</p>

<p>腾云驾雾的感觉，好开森！我说那是《楚门的世界》里的边际嘛，有一扇门，可以通往真相。</p>

<p><img src="/images/blog/20131023_0.jpg"></p>

<p>那边就是海了。那个小岛可能是台湾。</p>

<p><img src="/images/blog/20131023_1.jpg"></p>

<p>到了天津，转城际动车去北京。临时买票，到北京在西单附近，我观望了下，人的确是有点多，随便走了走我就去订好的民宿。</p>

<p>安顿好之后，第一个晚上我就就近逛逛，也没想说去哪里玩。</p>

<p>其实这次来北京已经是我出来玩，安排最充分的一次了，来往的车程和住宿都安排好了。虽然没有细具到每一天去哪些景点，我也不想要细具到这种细枝末节。我写了下大概想要去的地方，至于到底个什么安排，就全部随机了。导致我最后大概就去了总和的1/3，一来是因为一到北京就重感冒了身体不适，二来是累。好吧，还是因为身体不适。</p>

<p>第二天(4号)去了中关村，北京大学，颐和园。</p>

<p>第三天(5号)去了天安门，故宫，王府井，前门大街。</p>

<p>第四天(6号)去了798，跟MC见面吃饭，匆匆赶车去了。</p>

<p>颐和园的鸭子，为了看它，还做坑爹的船，所谓的游湖。</p>

<p><img src="/images/blog/20131023_2.jpg"></p>

<p>到处卖的北京老酸奶。好像没什么特别的味道。反正我鼻塞喝不出来。咦，我好像把瓶子买回来了，也不知道带回来没有。</p>

<p><img src="/images/blog/20131023_3.jpg"></p>

<p>他们说抹茶味超级浓郁的甜筒。我还是没有吃出什么味道，QAQ</p>

<p><img src="/images/blog/20131023_4.jpg"></p>

<p>没有人喜欢一个人孤孤单单的，我也不希望自己真的孤独终老。但是还是要做好一个人的准备。我去北京就好多人问我说，“不会吧，你一个人去啊！”我也不希望，永远都是一个人，去旅行。</p>

<p>虽然，一个人旅行没什么不好呀。</p>

<p>大不了，就是上厕所的时候，没人看包。必须要大包小包拎厕所里。</p>

<p>大不了，就是麦当劳吃饭忘了拿吸管，又没有人看着位置，只能掀盖子随便喝。</p>

<p>大不了，就是进一家饭店，点一个菜只能一个人吃。服务员还同情地看着一桌只有一个顾客的女屌丝</p>

<p><img src="/images/blog/20131023_5.jpg"></p>

<p>关于吃，我吃最多的还是小区门口的小摊贩，羊杂碎羊肉串粉丝砂锅炒粉干煎饼之类的，感冒好像胃口也不好。</p>

<p>去故宫租的讲解器，被它绕晕了，我好蠢。单身狗就是这样的。</p>

<p><img src="/images/blog/20131023_6.jpg"></p>

<p>798里的为艺术北漂的人们真是为他们感到心酸啊，可是他们有梦想。呵呵</p>

<p><img src="/images/blog/20131023_7.jpg"></p>

<p><img src="/images/blog/20131023_8.jpg"></p>

<p><img src="/images/blog/20131023_9.jpg"></p>

<p>没有爬长城，没有看升旗。其实我对自己说，只要我到了北京，我就是了了心愿。我感受到了北京的毒气，就够了。我就是看一看，看一看就够了啊。</p>

<p>有些事情，去做，就已经是成功了呢，不管最后体验到了什么。</p>

<p>困难一定会是有的，但是去做了，才知道困难是什么，想象出来的都不靠谱的。</p>

<p>在北京，遇到好人，也遇到不好的人，没有遇到坏人，已经是很幸运的事情了啊。</p>

<br>


<p>本来定的是7号晚上的高铁，好在刚到北京第一天我觉得说北京没什么好玩的，加之所谓的民宿还是不怎么踏实，叫大娘帮忙看看提早回杭州，结果就好巧不巧杭州7号台风，半个城都瘫痪了，我还好早一天回，7号在房间窝了一天，管人家涨大水撑船的。但6号那天的机票也是担心了我很久，怕受台风影响，在半路停不下来了。也的确，航班延误了大概半个小时，快到杭州的时候，还像开在贫困山区的道路上一样颠簸了5分钟。</p>

<br>


<br>


<p>最后不管怎么说，去做就好了，不要考虑说有什么意义。我想去，已经是最大的理由了吧。</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/21/collapsing-margins">
			
				外边距合并的其中一种</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-21T20:31:00+08:00" pubdate data-updated="true">Oct 21<span>st</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>外边距合并</code> <code>collapsing margins</code></p>

<br>


<p>群里的一位同学遇到的问题：<a href="http://jsbin.com/OdEyoh/3/edit">JSBin</a></p>

<p>原本是一个居中的问题，为什么position修改为<code>relative</code>就不能居中了呢？</p>

<p>因为这里莫名其妙地满足了外边距合并的情况：</p>

<ul>
<li><p>普通文档流的块级元素；</p></li>
<li><p>且一个元素包含在另一个元素中，没有<code>内边距</code>或<code>边框</code>把外边距分隔开。所以它们的上和/或下外边距发生了合并。所以麻烦都转移到父元素a上了。</p></li>
</ul>


<p>解决办法：</p>

<ul>
<li>使其中一个元素，变为<code>非</code>普通文档流中的块级元素，例如变为浮动元素(float)｜脱离文档流(position)｜内联元素(inline-block);</li>
<li>设置padding和border分开两个元素的外边距。(父元素上设置。子元素设置，还是没有把两个的margin分开好嘛)</li>
<li>父元素添加<code>overflow:hidden;</code></li>
</ul>


<p>一定要拜读的资料<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp">w3school-CSS 外边距合并</a></p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/15/handbook">
			
				爱整理的都是好姑凉</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-15T20:20:00+08:00" pubdate data-updated="true">Oct 15<span>th</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>手册</code></p>

<br>


<h3>开始装b</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake new_post["title"]
</span><span class='line'>rake generate
</span><span class='line'>rake deploy
</span><span class='line'>
</span><span class='line'>git add .
</span><span class='line'>git commit -m "Some comment here." 
</span><span class='line'>git push origin source</span></code></pre></td></tr></table></div></figure>


<h3>先睹为快</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake preview
</span><span class='line'># ctrl + c 退出预览</span></code></pre></td></tr></table></div></figure>


		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/15/javascript-function-invocation-patterns">
			
				JavaScript: 函数调用模式</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-15T19:38:00+08:00" pubdate data-updated="true">Oct 15<span>th</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>JavaScript</code> <code>this</code> <code>翻译</code></p>

<br>


<p>JavaScript被描述为一个面向函数语言（有别于面向对象的语言）。因为函数在JavaScript中不仅仅是独立的逻辑执行单元，函数是一等公民，它也提供作用域，且能创建对象。如此依赖函数有好有坏：好的是它使的语言轻且快速（也是该语言发展的初衷），坏的是如果你不知道你在做什么，你很容易把自己绕进去。</p>

<p>JavaScript函数一个需要关心的问题是，不同的调用模式可以产生截然不同的结果。这篇文章介绍了四种模式，如何使用它们，要注意些什么。四种调用模式如下：</p>

<p>1、方法调用（Method Invocation）</p>

<p>2、函数调用（Function Invocation）</p>

<p>3、构造函数调用（Constructor Invocation）</p>

<p>4、apply和call调用（Apply And Call Invocation）</p>

<h2>函数执行</h2>

<p>Javascript（像现今所有语言）函数有逻辑模块化的功能，它可以在执行的任何时候被调用。调用函数时，暂停执行当前函数，传递控制和参数给被调用的函数。此外，this参数也被传递给函数。调用操作符是一对圆括号（） ，它可以包含0个或多个以逗号分隔的表达式。</p>

<p>不幸的是，有多种模式可用来调用函数。这些模式并不是nice-to-know：绝对有必要了解它们。因为不同模式调用函数可以产生截然不同的结果。我认为这是JavaScript在语言设计上的错误，如果设计语言时多些思考（少些匆忙），也不会产生这么大的问题。</p>

<h2>四种调用模式</h2>

<p>虽然只有一个调用操作符（），但有四种调用模式。每种模式在初始化this参数时有所不同。</p>

<h3>方法调用</h3>

<p>对象中的函数，称为方法。方法调用是调用对象中的函数的模式。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">increment</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">increment</span><span class="p">();</span> <span class="c1">//Method invocation</span>
</span></code></pre></td></tr></table></div></figure>


<p>若函数前面有对象实例object，则称为方法调用。JavaScript将this参数指向调用方法的对象。如上例，this指向obj。Javascript在执行时绑定this（也被称为晚绑定）。</p>

<h3>函数调用</h3>

<p>使用（）调用函数，称为函数调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//5</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用函数调用模式，this指向全局对象。这是JavaScript语言中的错误！盲目绑定this到全局对象会破坏当前上下文。尤其是在方法函数内使用<code>内部函数</code>。下面这个例子做了很好地解释：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span> <span class="c1">//Global variable</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">increment</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">innerFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">innerFunction</span><span class="p">();</span> <span class="c1">//Function invocation pattern</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">increment</span><span class="p">();</span> <span class="c1">//Method invocation pattern</span>
</span></code></pre></td></tr></table></div></figure>


<p>你认为屏幕上显示什么？答案是1的，不好意思你错了（但不要太为难自己，这是JavaScript没有处理好）。真正的答案是500。注意，innerFunction使用函数调用模式，因此this被设置为全局对象。结果就是innerFunction（再次强调，它是函数调用模式）没有指向当前对象的this参数。相反，它（this）被设置到全局对象，其value值被定义为500。我要强调，这是很糟糕的语言设计；增量函数采用方法调用模式来调用，很自然地认为在内部使用它时，this应该总是指向当前函数。</p>

<p>有一个简单的方法来避开这个问题，但在我看来是一种hack。在函数内部定义一个变量（按照惯例，命名为that），将this赋值给这个变量。（题外话：这种方式可行使因为JavaScript中的函数是闭包）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">500</span><span class="p">;</span> <span class="c1">//Global variable</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">value</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>    <span class="nx">increment</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
</span><span class='line'>        <span class="nx">that</span><span class="p">.</span><span class="nx">value</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">innerFunction</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">alert</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">innerFunction</span><span class="p">();</span> <span class="c1">//Function invocation pattern</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">obj</span><span class="p">.</span><span class="nx">increment</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果this可以绑定到调用的当前对象作用域，函数和方法调用是一样的。</p>

<h3>构造函数调用</h3>

<p>注意：这是JavaScript另一个特点！JavaScript不是class式面向对象的语言。相反，它是一个propertype式面向对象的语言，但JavaScript的创建者认为，熟悉传统的面向对象经验的人（绝大多数）可能对纯粹的原型形式不满。这导致JavaScript对其原型特征不确定，最糟糕的事情发生了：它混合了经典的面向对象的语法和自身原型性质。结果：一塌糊涂！</p>

<p>传统的面向对象，对象是类的实例。在C++和Java中，这个实例是通过使用new操作符生成。这似乎是构造函数调用模式背后的灵感&hellip;</p>

<p>构造函数调用模式是，在被调用的函数之前用new操作符。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">Cheese</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">cheeseType</span> <span class="o">=</span> <span class="nx">type</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">cheeseType</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">cheddar</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Cheese</span><span class="p">(</span><span class="s2">&quot;cheddar&quot;</span><span class="p">);</span> <span class="c1">//new object returned, not the type.</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然Cheese是一个函数对象（有人将函数作为运行模块化的代码块），通过调用带new关键字的函数，来创建一个新的对象。this参数将指向新创建的对象，而函数的return操作符，will have its behaviour altered。关于构造函数调用的return操作符行为有两种情况：</p>

<p>1、如果该函数返回一个简单类型（number, string, boolean, null or undefined），忽略return，返回this（指向新的对象）。
2、如果该函数返回一个object实例（简单类型以外的任何类型），那么将返回的对象，而不是返回this。这种模式是不经常使用，但当它与闭包相结合的时候非常有用。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">data</span> <span class="o">:</span> <span class="s2">&quot;Hello World&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">Func1</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">Func2</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="s2">&quot;I am a simple type&quot;</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">f1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Func1</span><span class="p">();</span> <span class="c1">//f1 is set to obj</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">f2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Func2</span><span class="p">();</span> <span class="c1">//f2 is set to a new object</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可能会忽略JavaScript创建者给予该语言的独特之处：利用任意原型链创建对象，而只使用对象字面量来创建对象。这种模式很直观但也存在潜在问题。不过可以通过扩展对象的创建方法，实现构造函数调用模式的方法，<a href="http://doctrina.org/JavaScript:Why-Understanding-Scope-And-Closures-Matter.html#closureandconstructor">例子</a>。JavaScript 1.8.5实现了Object.create。构造函数调用仍然频繁使用。</p>

<h3>apply和call调用</h3>

<p>apply模式相比之前的模式，没有那么糟糕。apply方法允许，通过传递参数数组给函数来手动调用函数，明确设置this参数。因为函数是一等公民，他们也是对象，因此也可以运行方法（函数）。事实上，每一个function都指向Function.prototype,因此方法可以很容易扩展函数。apply方法就是一个函数扩展方法-我的猜想-它定义在Function.prototype中。</p>

<p>apply有两个参数：第一个参数是this参数绑定的对象，第二个参数是一个数组，它被映射为第一个对象的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">add</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">num1</span><span class="p">,</span> <span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">num1</span><span class="o">+</span><span class="nx">num2</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
</span><span class='line'><span class="nx">add</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="nx">array</span><span class="p">);</span> <span class="c1">//7</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子中，this为空（该函数不是一个对象，所以它不需要）和数组为num1与num2。第一个参数可以更有趣：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">data</span><span class="o">:</span><span class="s1">&#39;Hello World&#39;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">displayData</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">displayData</span><span class="p">();</span> <span class="c1">//undefined</span>
</span><span class='line'><span class="nx">displayData</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span> <span class="c1">//Hello World</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子使用apply绑定this到obj。结果产生一个this.data值。apply的实际应用价值,就是能明确分配一个值给this.。要是没有这个功能，我们可以直接使用（）来调用函数。</p>

<p>JavaScript还有种调用方法是call，类似apply方法,不过它传递的不是一个参数数组,而是一个参数列表。如果JavaScript可以实现的函数重载，我认为call应该是apply方法的重载。因此，人们谈论的apply和call其实是一样的。</p>

<h2>结论</h2>

<p>无论好坏，JavaScript都已经流行了。了解语言的特征,并避免这种特性带来的异常非常重要。学习四种函数调用方法哪里不同，以及如何避免缺陷是使用JavaScript的基础。</p>

<p>原文：<a href="http://doctrina.org/Javascript-Function-Invocation-Patterns.html">http://doctrina.org/Javascript-Function-Invocation-Patterns.html</a></p>

<h2>废话在后</h2>

<p>总结下this.</p>

<ol>
<li><p>对于obj.fun()此类方法函数调用,哪个<code>对象实例</code>(obj)调用this所在的函数(fun),this指向那个<code>对象实例</code></p></li>
<li><p>对于函数调用,this指向全局对象.(其实可以看做上一种,是window对象的方法函数,全局对象调用,则指向全局对象).避免这种语言设计不合理的一个小技巧就是,进入函数后就申明一个变量<em>this,赋值this给它(</em>this),保存下来.</p></li>
<li><p>对于构造函数调用,若该函数返回一个简单类型（number, string, boolean, null or undefined），忽略return值，返回this（指向新的对象）;如果该函数返回一个object实例（简单类型以外的任何类型），那么将返回该对象。</p></li>
<li><p>apply和call调用,this指向apply和call第一参数.即手动设置this的值.</p></li>
</ol>


<p>10 months ago 完.</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/12/no-longer">
			
				好像没有然后了</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-12T21:51:00+08:00" pubdate data-updated="true">Oct 12<span>th</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>随便</code></p>

<br>


<p>到目前，处理完字体，样式，分享，评论，百度统计，感觉又没有那么又激情了。感觉没有事情可做。</p>

<p>所以又是三分钟热度吗？</p>

<p>本来为了走向国际，或者学英语之类的，应该来个全英文的博客网站，至少导航和分类应该要国际化。但是，还是觉得文字对我有更多的吸引力。</p>

<p>目前准备了三个目录：</p>

<ul>
<li><p><a href="/blog/categories/ha-lou-!nu-yi-zhi/">哈喽！女汉纸</a></p></li>
<li><p><a href="/blog/categories/lai-lai-lai-he-wan-zhe-bei-huan-you-san-bei/">来来来喝完这杯还有三杯</a></p></li>
<li><p><a href="/blog/categories/2046/">2046</a></p></li>
</ul>


<p>最后一个目录还没开始写。这么聪明的你们知道每个目录啥玩意嘛哈哈哈！</p>

		
		
	</div>

</article>


    <article class="post">
	<header>
		<h2 class="title">
			
			<a href="/blog/2013/10/10/hello-again-octopress">
			
				Hello Again!Octopress</a>
		</h2>
		<div class="meta date">








  


<time datetime="2013-10-10T20:45:00+08:00" pubdate data-updated="true">Oct 10<span>th</span>, 2013</time></div>
	</header>
	<div class="entry-content">
		<p>tags: <code>折腾</code> <code>octopress</code></p>

<br>


<p>这是第一次在mac上折腾Octopress, 对于我这种数码/IT杀手来说， 跟win一样麻烦。</p>

<p>但成就感暴涨。尤其是<a href="http://summer222522.github.io/">茂茂</a>赞助了各种美好的<a href="https://github.com/imathis/octopress">主题</a>后，更加激动兴奋了！！</p>

<p>哈哈，最喜欢折腾了！<code>折腾无止境</code>！</p>

<p>但是折腾完之后，不知道可以坚持纪录多久的博客，求监督。</p>

<p>接下来， 正式总结此次折腾遇到的麻烦。</p>

<h3>坑</h3>

<ul>
<li>安装ruby——鉴于我手欠，早先删除了1个多G的Xcode，整个安装过程异常困难。由于我一直想要尝试用<a href="https://github.com/kennethreitz/osx-gcc-installer">戳工具</a>来代替这个鸡肋的Xcode。毕竟，任何无用却占据大量空间的东西都使我感到无比难过。我觉得哪天<code>猴年马月</code>一定要替换过来。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -L https://get.rvm.io | bash -s stable --ruby
</span><span class='line'>rvm install 1.9.3
</span><span class='line'>rvm use 1.9.3
</span><span class='line'>rvm rubygems latest</span></code></pre></td></tr></table></div></figure>


<ul>
<li>安装Octopress——安装依赖时，<code>rbenv rehash</code>总是提示没有这个命令。所以安装依赖的过程重复了好几次。最后<code>重启</code>，开<code>GoAgentX</code>，成功了。至于哪个原因造成的，我也不十分明了，有同样问题的可以参考<a href="http://liuyix.org/blog/2013/mac-install-octopress/">Mac上安装octopress</a>。</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clone git://github.com/imathis/octopress.git octopress
</span><span class='line'>cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
</span><span class='line'>ruby --version  # Should report Ruby 1.9.3
</span><span class='line'>gem install bundler
</span><span class='line'>rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
</span><span class='line'>bundle install
</span><span class='line'>rake install</span></code></pre></td></tr></table></div></figure>


<ul>
<li>将博客部署到GitHub上——像我这种MAC小白，以为在终端输入代码，没有红色就算是成功，第一步执行完居然默默地隐藏着设置用户名和邮箱，就是github帐户的用户名和密码。这里要提示一下，目前github已经修改为<code>username.github.io</code>，写<code>.com</code>有什么问题呢？因为输入url的提示已经更新了，我一开始仓库名写的是<code>coffeexu.girhub.com</code>，提示里是</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git@github.com:CoffeeXu/coffeexu.github.io.git
</span><span class='line'>or https://github.com/username/username.github.io.git</span></code></pre></td></tr></table></div></figure>


<p>显然我个猪头一来没粘贴仓库右下角的URL码，二来直接就将用户名改成了自己的名字。所以一直提示没有这个仓库。</p>

<p>如果使用的是ssh形式的url，需要得到当前笔记本用户的ssh，好像上面配置的时候会自动生产，如果需要手动添加的，戳<a href="https://help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a>。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake setup_github_pages
</span><span class='line'>rake generate
</span><span class='line'>rake deploy</span></code></pre></td></tr></table></div></figure>


<p>不知道你们是怎么样，反正我的<code>rake deploy</code>是没有提交到github上，大概是我前面重复太多遍了，一直提示有冲突。肿么办呢？强制合并，手动提交。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cd _deploy
</span><span class='line'>git add .
</span><span class='line'>git commit -m '手动提交_deploy'
</span><span class='line'>git push origin master</span></code></pre></td></tr></table></div></figure>


<h3>DIY</h3>

<ul>
<li><code>rake preview</code>如果木有在线的markdown预览的话，这个是写文章和修改主题时好方法啊，开起来之后，即时修改即时刷新就可以预览效果。</li>
<li>超链接。有没有发现我文章内的连接是打开新窗口的呢，markdown目前应该还不支持这种语法的，当然markdown是支持html。来自己动动手操作下。<a href="https://gist.github.com/azone/4523641">戳</a></li>
<li>目前的主题，自然是自己做过修改啦！自己动手，丰衣足食。哈哈。设置css样式基本在<code>sass/parts</code>目录下</li>
<li>文本上下间距。嫌弃默认的间距实在是太大了，改了下。文件同上</li>
<li>本来添加了加网和友言的评论，觉得太山寨了，档次一下就low了，删掉了。目前使用的addthis的分享和多说的评论。addthis不能分享到微信，缺陷。所以可能还是尽量使用国内的玩意儿更加符合国情吧。</li>
<li>tips.可以的话还是尽量看官方文档。当然最方便的就是——不要搞了啊！！！</li>
</ul>


		
		
	</div>

</article>

<nav id="pagenavi">
    
    
</nav>
</div>
	<footer id="footer" class="inner"><br>
&copy; 2013

    许嘘嘘


<!-- 
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-44761120-1', 'coffeexu.github.io');
  ga('send', 'pageview');

</script>
--></footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/hyphenator.js"></script>
<!-- 百度统计 -->
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fc792b5bcb2f241d17fdc3ba5f02de155' type='text/javascript'%3E%3C/script%3E"));
</script>



<script type="text/javascript">
      var disqus_shortname = 'coffeexu';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>






</body>
<script>
  $(document).ready(function() {
  // Make images center
  $('p:has(img)').css('text-align', 'center');
  });
</script>
</html>
