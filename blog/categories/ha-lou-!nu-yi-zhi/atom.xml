<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 哈喽！女汉纸 | 所以。]]></title>
  <link href="http://CoffeeXu.github.io/blog/categories/ha-lou-!nu-yi-zhi/atom.xml" rel="self"/>
  <link href="http://CoffeeXu.github.io/"/>
  <updated>2013-10-27T10:59:59+08:00</updated>
  <id>http://CoffeeXu.github.io/</id>
  <author>
    <name><![CDATA[许嘘嘘]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[外边距合并的其中一种]]></title>
    <link href="http://CoffeeXu.github.io/blog/2013/10/21/collapsing-margins"/>
    <updated>2013-10-21T20:31:00+08:00</updated>
    <id>http://CoffeeXu.github.io/blog/2013/10/21/collapsing-margins</id>
    <content type="html"><![CDATA[<p>tags: <code>外边距合并</code> <code>collapsing margins</code></p>

<br>


<p>群里的一位同学遇到的问题：<a href="http://jsbin.com/OdEyoh/3/edit">JSBin</a></p>

<p>原本是一个居中的问题，为什么position修改为<code>relative</code>就不能居中了呢？</p>

<p>因为这里莫名其妙地满足了外边距合并的情况：</p>

<ul>
<li><p>普通文档流的块级元素；</p></li>
<li><p>且一个元素包含在另一个元素中，没有<code>内边距</code>或<code>边框</code>把外边距分隔开。所以它们的上和/或下外边距发生了合并。所以麻烦都转移到父元素a上了。</p></li>
</ul>


<p>解决办法：</p>

<ul>
<li>使其中一个元素，变为<code>非</code>普通文档流中的块级元素，例如变为浮动元素(float)｜脱离文档流(position)｜内联元素(inline-block);</li>
<li>设置padding和border分开两个元素的外边距。(父元素上设置。子元素设置，还是没有把两个的margin分开好嘛)</li>
<li>父元素添加<code>overflow:hidden;</code></li>
</ul>


<p>一定要拜读的资料<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp">w3school-CSS 外边距合并</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爱整理的都是好姑凉]]></title>
    <link href="http://CoffeeXu.github.io/blog/2013/10/15/handbook"/>
    <updated>2013-10-15T20:20:00+08:00</updated>
    <id>http://CoffeeXu.github.io/blog/2013/10/15/handbook</id>
    <content type="html"><![CDATA[<p>tags: <code>手册</code></p>

<br>


<h3>开始装b</h3>

<p>```</p>

<pre><code>rake new_post["title"]
rake generate
rake deploy

git add .
git commit -m "Some comment here." 
git push origin source
</code></pre>

<p>```</p>

<h3>先睹为快</h3>

<p>```</p>

<pre><code>rake preview
# ctrl + c 退出预览
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript: 函数调用模式]]></title>
    <link href="http://CoffeeXu.github.io/blog/2013/10/15/javascript-function-invocation-patterns"/>
    <updated>2013-10-15T19:38:00+08:00</updated>
    <id>http://CoffeeXu.github.io/blog/2013/10/15/javascript-function-invocation-patterns</id>
    <content type="html"><![CDATA[<p>tags: <code>JavaScript</code> <code>this</code> <code>翻译</code></p>

<br>


<p>JavaScript被描述为一个面向函数语言（有别于面向对象的语言）。因为函数在JavaScript中不仅仅是独立的逻辑执行单元，函数是一等公民，它也提供作用域，且能创建对象。如此依赖函数有好有坏：好的是它使的语言轻且快速（也是该语言发展的初衷），坏的是如果你不知道你在做什么，你很容易把自己绕进去。</p>

<p>JavaScript函数一个需要关心的问题是，不同的调用模式可以产生截然不同的结果。这篇文章介绍了四种模式，如何使用它们，要注意些什么。四种调用模式如下：</p>

<p>1、方法调用（Method Invocation）</p>

<p>2、函数调用（Function Invocation）</p>

<p>3、构造函数调用（Constructor Invocation）</p>

<p>4、apply和call调用（Apply And Call Invocation）</p>

<h2>函数执行</h2>

<p>Javascript（像现今所有语言）函数有逻辑模块化的功能，它可以在执行的任何时候被调用。调用函数时，暂停执行当前函数，传递控制和参数给被调用的函数。此外，this参数也被传递给函数。调用操作符是一对圆括号（） ，它可以包含0个或多个以逗号分隔的表达式。</p>

<p>不幸的是，有多种模式可用来调用函数。这些模式并不是nice-to-know：绝对有必要了解它们。因为不同模式调用函数可以产生截然不同的结果。我认为这是JavaScript在语言设计上的错误，如果设计语言时多些思考（少些匆忙），也不会产生这么大的问题。</p>

<h2>四种调用模式</h2>

<p>虽然只有一个调用操作符（），但有四种调用模式。每种模式在初始化this参数时有所不同。</p>

<h3>方法调用</h3>

<p>对象中的函数，称为方法。方法调用是调用对象中的函数的模式。例如：
```javascript</p>

<pre><code>var obj = {
    value: 0,
    increment: function() {
        this.value+=1;
    }
};

obj.increment(); //Method invocation
</code></pre>

<p>```</p>

<p>若函数前面有对象实例object，则称为方法调用。JavaScript将this参数指向调用方法的对象。如上例，this指向obj。Javascript在执行时绑定this（也被称为晚绑定）。</p>

<h3>函数调用</h3>

<p>使用（）调用函数，称为函数调用：</p>

<p>```javascript</p>

<pre><code>add(2,3); //5
</code></pre>

<p>```</p>

<p>使用函数调用模式，this指向全局对象。这是JavaScript语言中的错误！盲目绑定this到全局对象会破坏当前上下文。尤其是在方法函数内使用<code>内部函数</code>。下面这个例子做了很好地解释：</p>

<p>```javascript</p>

<pre><code>var value = 500; //Global variable
var obj = {
    value: 0,
    increment: function() {
        this.value++;

        var innerFunction = function() {
            alert(this.value);
        }

        innerFunction(); //Function invocation pattern
    }
}
obj.increment(); //Method invocation pattern
</code></pre>

<p>```</p>

<p>你认为屏幕上显示什么？答案是1的，不好意思你错了（但不要太为难自己，这是JavaScript没有处理好）。真正的答案是500。注意，innerFunction使用函数调用模式，因此this被设置为全局对象。结果就是innerFunction（再次强调，它是函数调用模式）没有指向当前对象的this参数。相反，它（this）被设置到全局对象，其value值被定义为500。我要强调，这是很糟糕的语言设计；增量函数采用方法调用模式来调用，很自然地认为在内部使用它时，this应该总是指向当前函数。</p>

<p>有一个简单的方法来避开这个问题，但在我看来是一种hack。在函数内部定义一个变量（按照惯例，命名为that），将this赋值给这个变量。（题外话：这种方式可行使因为JavaScript中的函数是闭包）：</p>

<p>```javascript
var value = 500; //Global variable
var obj = {</p>

<pre><code>value: 0,
increment: function() {
    var that = this;
    that.value++;

    var innerFunction = function() {
        alert(that.value);
    }

    innerFunction(); //Function invocation pattern
}
</code></pre>

<p>}
obj.increment();
```</p>

<p>如果this可以绑定到调用的当前对象作用域，函数和方法调用是一样的。</p>

<h3>构造函数调用</h3>

<p>注意：这是JavaScript另一个特点！JavaScript不是class式面向对象的语言。相反，它是一个propertype式面向对象的语言，但JavaScript的创建者认为，熟悉传统的面向对象经验的人（绝大多数）可能对纯粹的原型形式不满。这导致JavaScript对其原型特征不确定，最糟糕的事情发生了：它混合了经典的面向对象的语法和自身原型性质。结果：一塌糊涂！</p>

<p>传统的面向对象，对象是类的实例。在C++和Java中，这个实例是通过使用new操作符生成。这似乎是构造函数调用模式背后的灵感&hellip;</p>

<p>构造函数调用模式是，在被调用的函数之前用new操作符。例如：</p>

<p>```javascript
var Cheese = function(type) {</p>

<pre><code>var cheeseType = type;
return cheeseType;
</code></pre>

<p>}</p>

<p>cheddar = new Cheese(&ldquo;cheddar&rdquo;); //new object returned, not the type.
```</p>

<p>虽然Cheese是一个函数对象（有人将函数作为运行模块化的代码块），通过调用带new关键字的函数，来创建一个新的对象。this参数将指向新创建的对象，而函数的return操作符，will have its behaviour altered。关于构造函数调用的return操作符行为有两种情况：</p>

<p>1、如果该函数返回一个简单类型（number, string, boolean, null or undefined），忽略return，返回this（指向新的对象）。
2、如果该函数返回一个object实例（简单类型以外的任何类型），那么将返回的对象，而不是返回this。这种模式是不经常使用，但当它与闭包相结合的时候非常有用。</p>

<p>例如：
```javascript
var obj = {</p>

<pre><code>data : "Hello World"
</code></pre>

<p>}</p>

<p>var Func1 = function() {</p>

<pre><code>return obj;
</code></pre>

<p>}</p>

<p>var Func2 = function() {</p>

<pre><code>return "I am a simple type";
</code></pre>

<p>}</p>

<p>var f1 = new Func1(); //f1 is set to obj
var f2 = new Func2(); //f2 is set to a new object
```</p>

<p>我们可能会忽略JavaScript创建者给予该语言的独特之处：利用任意原型链创建对象，而只使用对象字面量来创建对象。这种模式很直观但也存在潜在问题。不过可以通过扩展对象的创建方法，实现构造函数调用模式的方法，<a href="http://doctrina.org/JavaScript:Why-Understanding-Scope-And-Closures-Matter.html#closureandconstructor">例子</a>。JavaScript 1.8.5实现了Object.create。构造函数调用仍然频繁使用。</p>

<h3>apply和call调用</h3>

<p>apply模式相比之前的模式，没有那么糟糕。apply方法允许，通过传递参数数组给函数来手动调用函数，明确设置this参数。因为函数是一等公民，他们也是对象，因此也可以运行方法（函数）。事实上，每一个function都指向Function.prototype,因此方法可以很容易扩展函数。apply方法就是一个函数扩展方法-我的猜想-它定义在Function.prototype中。</p>

<p>apply有两个参数：第一个参数是this参数绑定的对象，第二个参数是一个数组，它被映射为第一个对象的参数：</p>

<p>```javascript
var add = function(num1, num2) {</p>

<pre><code>    return num1+num2;
</code></pre>

<p>}</p>

<p>array = [3,4];
add.apply(null,array); //7
```</p>

<p>上面的例子中，this为空（该函数不是一个对象，所以它不需要）和数组为num1与num2。第一个参数可以更有趣：</p>

<p>```javascript
var obj = {</p>

<pre><code>data:'Hello World'
</code></pre>

<p>}</p>

<p>var displayData = function() {</p>

<pre><code>alert(this.data);
</code></pre>

<p>}</p>

<p>displayData(); //undefined
displayData.apply(obj); //Hello World
```</p>

<p>上面的例子使用apply绑定this到obj。结果产生一个this.data值。apply的实际应用价值,就是能明确分配一个值给this.。要是没有这个功能，我们可以直接使用（）来调用函数。</p>

<p>JavaScript还有种调用方法是call，类似apply方法,不过它传递的不是一个参数数组,而是一个参数列表。如果JavaScript可以实现的函数重载，我认为call应该是apply方法的重载。因此，人们谈论的apply和call其实是一样的。</p>

<h2>结论</h2>

<p>无论好坏，JavaScript都已经流行了。了解语言的特征,并避免这种特性带来的异常非常重要。学习四种函数调用方法哪里不同，以及如何避免缺陷是使用JavaScript的基础。</p>

<p>原文：<a href="http://doctrina.org/Javascript-Function-Invocation-Patterns.html">http://doctrina.org/Javascript-Function-Invocation-Patterns.html</a></p>

<h2>废话在后</h2>

<p>总结下this.</p>

<ol>
<li><p>对于obj.fun()此类方法函数调用,哪个<code>对象实例</code>(obj)调用this所在的函数(fun),this指向那个<code>对象实例</code></p></li>
<li><p>对于函数调用,this指向全局对象.(其实可以看做上一种,是window对象的方法函数,全局对象调用,则指向全局对象).避免这种语言设计不合理的一个小技巧就是,进入函数后就申明一个变量<em>this,赋值this给它(</em>this),保存下来.</p></li>
<li><p>对于构造函数调用,若该函数返回一个简单类型（number, string, boolean, null or undefined），忽略return值，返回this（指向新的对象）;如果该函数返回一个object实例（简单类型以外的任何类型），那么将返回该对象。</p></li>
<li><p>apply和call调用,this指向apply和call第一参数.即手动设置this的值.</p></li>
</ol>


<p>10 months ago 完.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello Again!Octopress]]></title>
    <link href="http://CoffeeXu.github.io/blog/2013/10/10/hello-again-octopress"/>
    <updated>2013-10-10T20:45:00+08:00</updated>
    <id>http://CoffeeXu.github.io/blog/2013/10/10/hello-again-octopress</id>
    <content type="html"><![CDATA[<p>tags: <code>折腾</code> <code>octopress</code></p>

<br>


<p>这是第一次在mac上折腾Octopress, 对于我这种数码/IT杀手来说， 跟win一样麻烦。</p>

<p>但成就感暴涨。尤其是<a href="http://summer222522.github.io/">茂茂</a>赞助了各种美好的<a href="https://github.com/imathis/octopress">主题</a>后，更加激动兴奋了！！</p>

<p>哈哈，最喜欢折腾了！<code>折腾无止境</code>！</p>

<p>但是折腾完之后，不知道可以坚持纪录多久的博客，求监督。</p>

<p>接下来， 正式总结此次折腾遇到的麻烦。</p>

<h3>坑</h3>

<ul>
<li>安装ruby——鉴于我手欠，早先删除了1个多G的Xcode，整个安装过程异常困难。由于我一直想要尝试用<a href="https://github.com/kennethreitz/osx-gcc-installer">戳工具</a>来代替这个鸡肋的Xcode。毕竟，任何无用却占据大量空间的东西都使我感到无比难过。我觉得哪天<code>猴年马月</code>一定要替换过来。</li>
</ul>


<p>```</p>

<pre><code>curl -L https://get.rvm.io | bash -s stable --ruby
rvm install 1.9.3
rvm use 1.9.3
rvm rubygems latest
</code></pre>

<p>```</p>

<ul>
<li>安装Octopress——安装依赖时，<code>rbenv rehash</code>总是提示没有这个命令。所以安装依赖的过程重复了好几次。最后<code>重启</code>，开<code>GoAgentX</code>，成功了。至于哪个原因造成的，我也不十分明了，有同样问题的可以参考<a href="http://liuyix.org/blog/2013/mac-install-octopress/">Mac上安装octopress</a>。</li>
</ul>


<p>```</p>

<pre><code>git clone git://github.com/imathis/octopress.git octopress
cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
ruby --version  # Should report Ruby 1.9.3
gem install bundler
rbenv rehash    # If you use rbenv, rehash to be able to run the bundle command
bundle install
rake install
</code></pre>

<p>```</p>

<ul>
<li>将博客部署到GitHub上——像我这种MAC小白，以为在终端输入代码，没有红色就算是成功，第一步执行完居然默默地隐藏着设置用户名和邮箱，就是github帐户的用户名和密码。这里要提示一下，目前github已经修改为<code>username.github.io</code>，写<code>.com</code>有什么问题呢？因为输入url的提示已经更新了，我一开始仓库名写的是<code>coffeexu.girhub.com</code>，提示里是
<code>
  git@github.com:CoffeeXu/coffeexu.github.io.git
  or https://github.com/username/username.github.io.git
</code>
显然我个猪头一来没粘贴仓库右下角的URL码，二来直接就将用户名改成了自己的名字。所以一直提示没有这个仓库。</li>
</ul>


<p>如果使用的是ssh形式的url，需要得到当前笔记本用户的ssh，好像上面配置的时候会自动生产，如果需要手动添加的，戳<a href="https://help.github.com/articles/generating-ssh-keys">Generating SSH Keys</a>。</p>

<p>```</p>

<pre><code>rake setup_github_pages
rake generate
rake deploy
</code></pre>

<p><code>
不知道你们是怎么样，反正我的`rake deploy`是没有提交到github上，大概是我前面重复太多遍了，一直提示有冲突。肿么办呢？强制合并，手动提交。
</code></p>

<pre><code>cd _deploy
git add .
git commit -m '手动提交_deploy'
git push origin master
</code></pre>

<p>```</p>

<h3>DIY</h3>

<ul>
<li><code>rake preview</code>如果木有在线的markdown预览的话，这个是写文章和修改主题时好方法啊，开起来之后，即时修改即时刷新就可以预览效果。</li>
<li>超链接。有没有发现我文章内的连接是打开新窗口的呢，markdown目前应该还不支持这种语法的，当然markdown是支持html。来自己动动手操作下。<a href="https://gist.github.com/azone/4523641">戳</a></li>
<li>目前的主题，自然是自己做过修改啦！自己动手，丰衣足食。哈哈。设置css样式基本在<code>sass/parts</code>目录下</li>
<li>文本上下间距。嫌弃默认的间距实在是太大了，改了下。文件同上</li>
<li>本来添加了加网和友言的评论，觉得太山寨了，档次一下就low了，删掉了。目前使用的addthis的分享和多说的评论。addthis不能分享到微信，缺陷。所以可能还是尽量使用国内的玩意儿更加符合国情吧。</li>
<li>tips.可以的话还是尽量看官方文档。当然最方便的就是——不要搞了啊！！！</li>
</ul>

]]></content>
  </entry>
  
</feed>
